---
layout: post
title:  "Coding Interview 3.Recursion and Backtracking"
date:   2018-08-13
excerpt: "코딩인터뷰 3장 재귀와 역추적"
tag:
- 코딩 인터뷰
- 재귀
- Recursion
- 역추적
- Backtracking

comments: true
---
* auto-gen TOC:
{:toc}

# 재귀(Recursion), 역추적(Backtracking)

> 도서 코딩 인터뷰 퀘스천을 읽고 정리한 내용입니다.

## 재귀란 무엇인가?

자기 자신을 반복해서 호출하는 모든 함수를 재귀적, Recursive이라 한다. 보다 작은 문제로 작업하기 위해 자기 자신의 복사본을 호출하여 문제를 해결한다. 정렬(sort), 검색(search), 탐색(traversal)문제들이 간단한 예이다.

- base case, 종료 조건

  함수가 더 이상 재귀를 호출하지 않는 경우

- recursive case, 재귀 조건

  하위 작업 수행을 위해 자기 자신을 호출하는 경우

- 예시, Factorial

      //factorial의 재귀적 정의
      n! = 1, if n=0
      n! = n*(n-1)!, if n>0

      //양수의 팩토리얼
      int Fact(int n){
      	//base case 0 또는 1의 팩토리얼은 1
      	if (n==1) return 1;
      	else if(n==0) return 1;
      	else return n*Fact(n-1);
      }

## 재귀와 메모리(Visualization)

재귀 호출은 메모리에 해당 함수의 복사본을 만든다. 함수가 종료되면, 반환 함수의 복사본은 메모리에서 제거된다.

## 재귀 vs 반복

어떤 방식이 더 좋을까?

재귀적 접근은 명확한 답이 없을 수도 있는 문제를 풀기 위해서 문제를 단순화 시킨다. 재귀 호출마다 오버헤드가 더해진다. 추가적인 공간이 필요하다. 무한 재귀에 봉착하면 메모리가 부족해서 스택 오버플로우가 발생하게 된다.

반복방식은  추가적인 공간을 필요로 하지 않는다. 하지만 항상 재귀적인 방법보다 명확한 것은 아니다.

## 재귀 방식에 대한 참고사항

두가지 유형, 재귀 조건, 종료 조건이 있다. 모든 함수는 종료 조건에서 종료되어야 한다.

일반적으로 반복 방식이 재귀 방식보다 효율적이다. (오버헤드)

몇몇 문제에서는 재귀적인 해결책이 적합할 수 있다.

## 재귀 알고리즘의 예

- 피보나치 수열, 팩토리얼
- 병합 정렬, 퀵 정렬
- 2진 검색
- 트리 탐색, 많은 트리 문제(중위, 전위, 후위)
- 그래프 탐색 : 깊이 우선(Depth Find Search), 너비 우선(Breath First Search)
- 동적 프로그래밍 예제
- 분할과 정복 알고리즘
- 하노이의 탑
- 역 추적 알고리즘

## 재귀 방식의 문제

- 하노이의 탑 퍼즐

  세 개의 막대에 서로 다른 크기의 원반들이 있다. 한 막대에 위로 갈 수록 더 작은 크기 순서로 꽂혀 원뿔 모양을 한 원반들로 시작한다.

![hanoi-2049d7e1-6b9b-4f9c-955a-f659bd772dd0](https://user-images.githubusercontent.com/37807838/44011276-a5a08dba-9ef2-11e8-88ec-1f0647805c2a.jpg)

  아래 규칙을 지켜서 문제를 해결한다.

  - 한 번에 한 개의 원반만 이동한다.
  - 각 이동은 원반이 꽂혀있는 막대기에서 가장 상단에 있는 원반을 빼서 다른 막대기에 꽂는데 이미 원반이 있을 경우 그 위에 놓는다.
  - 어떤 원반도 더 작은 원반 위에 위치 할 수 없다.

  이 문제를 풀 수 있는 알고리즘은 다음과 같다.

  - 원반이 쌓여있는 기존 막대기 최상단 n-1 원반을 보조 막대로 이동한다.
  - n번째 원반을 다시 쌓기로 결정한 목표 막대로 이동한다.
  - n-1번째 원반을 보조 막대에서 목표 막대로 이동한다.
  - 다시 위 과정을 반복한다.

  코드로 표현하면 다음과 같다.

      void Hanoi(int n, char fromStick, char goalStick, char auxStick){
      	//원반이 하나면 옮기고 끝
      	if(n==1){
      		printf("원반 1을 %c 에서 %c로 옮김.",fromStick,goalStick);
      	}
      	//최상단의 n-1을 C막대를 기준으로 A에서 B로 옮김
      	Hanoi(n-1, fromStick, auxStick, goalStick);

      	//남은 원반을 A에서 C로 옮김
      	printf("%d번 디스크를 %c막대에서 %c막대로 이동.",n,fromStick,goalStick);

      	//최상단의 n-1을 C를 기준으로 A에서 B로 옮김
      	Hanoi(n-1, auxStick, goalStick, fromStick);

## 역추적이란?

분할 정복을 사용하는 완전 검색(Exhausitive Search) 방법이다.

때때로 어떤 문제에 대한 최선의 알고리즘은 모든 가능성을 시도해 보는 것일 수도 있다.

느리지만 다음과 같은 표준 도구들을 갖고 있다.

- 2진 문자열(n 비트 문자열에 대해 2^n가지 가능성)과 같은 기본 객체를 생성하기 위한 알고리즘
- 순열,Permutation
- 조합 n!/r!(n-r)!
- 일반 문자열(길이가 n인 문자열은 k^n가지 가능성이 있음)
